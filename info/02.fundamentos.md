# 2.Fundamentos

- Fundamentos Javascript (2) - Operadores y expresiones

## √çndice

- [2.Fundamentos](#2fundamentos)
  - [√çndice](#√≠ndice)
  - [Expresiones y operadores](#expresiones-y-operadores)
    - [Instrucciones o sentencias (statements)](#instrucciones-o-sentencias-statements)
    - [Expresiones (Expressions)](#expresiones-expressions)
    - [Operadores](#operadores)
      - [Operadores primarios](#operadores-primarios)
      - [Operadores del lado izquierdo (left-hand-side)](#operadores-del-lado-izquierdo-left-hand-side)
      - [Operadores de asignaci√≥n](#operadores-de-asignaci√≥n)
      - [Operadores de incremento y decremento](#operadores-de-incremento-y-decremento)
      - [Operadores aritm√©ticos](#operadores-aritm√©ticos)
      - [Operadores aritm√©ticos + asignaci√≥n](#operadores-aritm√©ticos--asignaci√≥n)
      - [Operadores unarios](#operadores-unarios)
      - [Operadores relacionales y de igualdad](#operadores-relacionales-y-de-igualdad)
      - [Operador ternario](#operador-ternario)
      - [Operadores de cadena](#operadores-de-cadena)
      - [Operadores l√≥gicos](#operadores-l√≥gicos)
      - [Operadores l√≥gicos + asignaci√≥n](#operadores-l√≥gicos--asignaci√≥n)
      - [Otros Operadores](#otros-operadores)
  - [Control de flujo](#control-de-flujo)
    - [Condicionales](#condicionales)
      - [If](#if)
      - [Operador ternario](#operador-ternario-1)
      - [Switch - Case](#switch---case)
    - [Iteraciones incondicionales](#iteraciones-incondicionales)
      - [for](#for)
      - [for of](#for-of)
      - [for in](#for-in)
      - [sentencias break y continue](#sentencias-break-y-continue)
    - [Iteraciones condicionales](#iteraciones-condicionales)
      - [do](#do)
      - [while](#while)
    - [Control de excepciones (errores)](#control-de-excepciones-errores)
      - [Excepciones provocadas](#excepciones-provocadas)
  - [M√≥dulos](#m√≥dulos)
    - [Importaci√≥n din√°mica](#importaci√≥n-din√°mica)
    - [Metadatos de los m√≥dulos](#metadatos-de-los-m√≥dulos)

## Expresiones y operadores

### Instrucciones o sentencias (statements)

- simples

  - declaraci√≥n de variables
  - asignaci√≥n de valores: assignment: A:= A + 5
  - assertion: assert(ptr != NULL);
  - llamada a funciones y m√©todos: call‚Ä¶
  - devoluci√≥n de valores y del control: return ‚Ä¶

- complejas (control de flujo)
  - creaci√≥n de bloques de c√≥digo: block: begin ‚Ä¶ end
  - bifurcaciones en funci√≥n de condiciones: if / switch
  - iteraciones en bloques de c√≥digo (bucles): while / do / for:

Las instrucciones (statements) no tienen que devolver resultados.
Muchas veces son ejecutadas √∫nicamente por los efectos que tienen (side effects).

### Expresiones (Expressions)

Siempre se eval√∫an (devuelven) a un √∫nico resultado.
A menudo no tienen efectos (side effects) en si mismas

Se componen de

- valores literales
- variables o constantes
- operadores

Seg√∫n el uso de estos elementos tendremos distintos tipos de expresiones

- expresiones literales: valores
- expresiones de identificador (variables)
- expresiones de asignaci√≥n y de los diversos tipos de operadores (aritm√©ticas, de comparaci√≥n, l√≥gicas)
- expresiones de ejecuci√≥n (llamadas a funciones)

La mayor√≠a de las expresiones est√°n en realidad compuestas de m√∫ltiples expresiones:

- Expresi√≥n de asignaci√≥n basada en una expresi√≥n literal

```js
const a = 22;
```

- Expresi√≥n de asignaci√≥n basada en una expresi√≥n aritm√©tica, que a su vez utiliza un literal y una expresi√≥n de identificador

```js
const b = a + 22;
```

### Operadores

Los operadores pueden ser de diversos tipos

#### Operadores primarios

Son palabras clave b√°sicas y expresiones con la m√°xima precedencia frente a otros operadores:

- literales
- `[]`, `{}`, `//`, `()`
- `function`
- `this`
- ` `` ` [_üóìÔ∏èES2015_]: template strings
- `class` [_üóìÔ∏èES2015_]: clases en ES6
- `async` [_üóìÔ∏èES2017_]: funciones as√≠ncronas

#### Operadores del lado izquierdo (left-hand-side)

Ayudan a definir la parte izquierda de una asignaci√≥n

- accessors de las propiedades:
  - punto (`.`) y corchetes (`[]`)
  - optional chaining (`?.`) [_üóìÔ∏èES2019_]
- `new`
- `super` [_üóìÔ∏èES2015_]: referencia a la clase padre en ES6
- `import`() [_üóìÔ∏èES2020_]: imports din√°micos en los m√≥dulos ESM
- `import.meta` [_üóìÔ∏èES2020_]: metadatos en los m√≥dulos

Como veremos al hablar de los objetos, El optional chaining (`?.`) devuelve undefined en lugar de causar un error si la referencia es **nullish** (null or undefined).

```js
let x;
console.log(x.address); // undefined
```

#### Operadores de asignaci√≥n

```js
let x = 22;
console.log(x); // 22
```

#### Operadores de incremento y decremento

```js
let x = 22;
console.log(++x); // 23
console.log(--x); // 22
x = 30;
console.log(x++); // 30
console.log(x); // 31
x = 30;
console.log(x--); // 30
console.log(x); // 29
```

#### Operadores aritm√©ticos

- Los s√≠mbolos de las cuatro operaciones aritm√©ticas b√°sicas: `+`, `-`, `*`, `/`
- El m√≥dulo o resto de la divisi√≥n entera: `%`
- El operador exponente (`**`) [_üóìÔ∏èES2016_]

```js
const a = 5;
const b = 2;
console.log(a + b); // 7
console.log(a - b); // 3
console.log(a * b); // 10
console.log(a / b); // 2.5
console.log(a % b); // 1 (m√≥dulo o resto)
console.log(a ** b); // 25 (exponente)
```

#### Operadores aritm√©ticos + asignaci√≥n

```js
let x = 2;
x += 2;
console.log(x); // 4
x -= 2;
console.log(x); // 2
x *= 2;
console.log(x); // 4
x /= 2;
console.log(x); // 2
x **= 2;
console.log(x); // 4
x %= 2;
console.log(x); // 0
```

#### Operadores unarios

- operadores de signo (`+`, `-`)
- `delete`, `void`, `typeof`, `await`
- logical NOT (`!`)

```js
let x = 2;
let y = -2;
console.log(+x, -x);
console.log(+y, -y);
```

#### Operadores relacionales y de igualdad

- s√≠mbolos de comparaci√≥n
- `instanceof`
- `in`

Devuelven en todos los casos el valor booleano resultante de la operaci√≥n

```js
const a = 2;
const b = 3;
console.log(a == b); // false
console.log(a != b); // true
console.log(a >= b); // false
console.log(a <= b); // true
console.log(a > b); // false
console.log(a < b); // true
console.log(a === b); // false
console.log(a !== b); // true
console.log([] instanceof Array); // true
console.log(3 in [1, 2]); // false
```

#### Operador ternario

```js
let age = 15;
console.log(age >= 18 ? 'Mayor de edad' : 'Menor');
age = 23;
console.log(age >= 18 ? 'Mayor de edad' : 'Menor');
```

#### Operadores de cadena

El operador de concatenaci√≥n tiende a dejar de ser utilizado debido al empleo de template strings

```js
const a = 'Pepe';
const b = 'Perez';
console.log(a + ' ' + b); // Pepe Perez
console.log(`${a} ${b}`); // Pepe Perez
```

#### Operadores l√≥gicos

- AND (`&&`), OR (`||`)
- el operador unario logical NOT (`!`)
- nullish coalescing (`??`) [_üóìÔ∏èES2019_]: eval√∫a el segundo t√©rmino s√≥lo si el primero es **nullish** (null or undefined)

Siguen el principio de cortocircuito (short circuit breaker), por lo que si un operando es suficiente para determinar el resultado, no son evaluados los siguientes

&& devuelve el primer operando falsy, o el √∫ltimo truthy
|| devuelve el primer operando truthy, o el √∫ltimo falsy
?? devuelve el primer operando NO nullish, o el √∫ltimo nullish

```js
const a = 22;
const b = 'Pepe';

console.log(a && b); // Pepe
console.log(a || b); // 22
console.log(!a && b); // false
console.log(a ?? b); // 22
console.log(null ?? b); // 'Pepe'
console.log(undefined ?? b); // 'Pepe'
```

#### Operadores l√≥gicos + asignaci√≥n

[_üóìÔ∏èES2021_] Logical Assignment Operators

- `||=` (Or Or Equals): solo si el operando de la izquierda es falsy, eval√∫a el operando de la derecha y lo asigna
- `&&=` (And And Equals): solo si el operando de la izquierda es truthy, eval√∫a el operando de la derecha y lo asigna
- `??=` (QQ Equals): solo si el operando de la izquierda es nullish, eval√∫a el operando de la derecha y lo asigna

```js
let x = 1;
let y = 2;
x ||= y; // x || (x = y);
console.log(x); // 1

x &&= y; // x && (x = y);
console.log(x); // 2

x = 1;
x ??= y; // x ?? (x = y);
console.log(x); // 1
x = null;
x ??= y; // x ?? (x = y);
console.log(x); // 2
```

#### Otros Operadores

- operador `,`
- operador spread/rest (`...`) [_üóìÔ∏èES2015_]

No se recogen los diversos tipos de operadores binarios, que no usaremos.

Lo mismo sucede con el operador `yield`, usado en los generadores, que tampoco veremos [_üóìÔ∏èES2015_]

## Control de flujo

1. Condicionales
   1. If
   2. Switch - Case
   3. Operador ternario
2. Iteraciones Incondicionales
   1. for
   2. for in
   3. for of
   4. sentencias break y continue
3. Iteraciones condicionales
   1. do y while
4. Control de excepciones (errores)

### Condicionales

#### If

Se eval√∫an una o distintas condiciones y en caso de cumplirse, se ejecuta un bloque de c√≥digo.

```js
const sayByAge = (age = 0) => {
  let msg = '';
  if (age < 12) {
    msg = 'Todav√≠a eres muy peque√±o';
  } else if (age < 19) {
    msg = 'Eres un adolescente';
  } else if (age < 35) {
    msg = 'Aun sigues siendo joven';
  } else {
    msg = 'Piensa en cuidarte un poco m√°s';
  }
  return msg;
};

console.log(sayByAge(12));
console.log(sayByAge(22));
console.log(sayByAge(40));
```

Dentro de una funci√≥n las condiciones pueden incluir directamente el retorno, con lo que se obvia cualquier comprobaci√≥n posterior

```js
const sayByAge = (age = 0) => {
  if (age < 12) {
    return 'Todav√≠a eres muy peque√±o';
  }
  if (age < 19) {
    return 'Eres un adolescente';
  }
  if (age < 35) {
    return 'Aun sigues siendo joven';
  }
  return 'Piensa en cuidarte un poco m√°s';
};

console.log(sayByAge(12));
console.log(sayByAge(22));
console.log(sayByAge(40));
```

La **expresi√≥n** que acompa√±a al if entre par√©ntesis **siempre** se eval√∫a a **boolean**, incluso si no incluye ning√∫n operador relacional

```js
const isTrue = (value) => {
  const msg = `El valor ${value} se eval√∫a a `;
  if (value) return `${msg} verdadero`;
  return `${msg} falso`;
};

console.log(isTrue('Hola'));
console.log(isTrue(''));
```

Cuando el bloque de c√≥digo correspondiente a un if es un **return de una sola l√≠nea**, se pueden dejar de acotarlo mediante llaves ({})

#### Operador ternario

En casos sencillos como el anterior, la evaluaci√≥n de la condici√≥n puede hacerse mediante el uso del operador ternario

```js
const isTrue = (value) => {
  const msg = `El valor ${value} se eval√∫a a `;
  if (value) return `${msg} verdadero`;
  return `${msg} falso`;
};

console.log(isTrue('Hola'));
console.log(isTrue(''));
```

Al ser una expresi√≥n, la comparaci√≥n mediante el operador ternario puede utilizarse directamente all√≠ donde se espera una expresi√≥n, por ejemplo en un template string

```js
const isTrue = (value) => {
  return `El valor ${value} se eval√∫a a ${value ? 'verdadero' : 'falso'}`;
};

console.log(isTrue('Hola'));
console.log(isTrue(''));
```

#### Switch - Case

Para realizar comprobaciones m√∫ltiples y tomar decisiones complejas, si estas dependen siempre dela misma variable, el repetido uso de if es redundante y puede sustituirse mediante la estructura de control switch

- La variable siempre la misma se indica al principio
- Cada case corresponde a un valor posible de dicha variable
- Si el case no incluye un break o un return, continuaran evalu√°ndose los siguientes valores
- La inclusi√≥n de default es opcional
- La evaluaci√≥n sigue el orden en que se escribe el c√≥digo, por lo que dicho orden es determinante

```js
const saySeason = (month) => {
  let season;
  switch (month) {
    case 'Octubre':
    case 'Noviembre':
    case 'Diciembre':
      season = 'Oto√±o';
      break;
    case 'Enero':
    case 'Febrero':
    case 'Marzo':
      season = 'Invierno';
      break;
    default:
      season = 'Primavera o Verano';
      break;
  }
  return season;
};

console.log(saySeason('Enero'));
console.log(saySeason('Agosto'));
```

Si las condiciones forman parte de una funci√≥n, el final de cada bloque de ejecuci√≥n puede ser tambi√©n un return, como ocurre en el caso de los if

```js
const saySeason = (month) => {
  switch (month) {
    case 'Octubre':
    case 'Noviembre':
    case 'Diciembre':
      return 'Oto√±o';
    case 'Enero':
    case 'Febrero':
    case 'Marzo':
      return 'Invierno';
  }
  return 'Primavera o Verano';
};

console.log(saySeason('Enero'));
console.log(saySeason('Agosto'));
```

La omisi√≥n del break permite agrupar c√≥digo v√°lido para varios valores, aunque esto mismo puede hacerse con el operador OR (||)

```js
const saySeason = (month) => {
  switch (month) {
    case 'Octubre' || 'Noviembre' || 'Diciembre':
      return 'Oto√±o';
    case 'Enero' || 'Febrero' || 'Marzo':
      return 'Invierno';
  }
  return 'Primavera o Verano';
};

console.log(saySeason('Enero'));
console.log(saySeason('Agosto'));
```

### Iteraciones incondicionales

Hay varios mecanismos de iteraci√≥n (bucles) que se inician con un n√∫mero de vueltas predefinidos en el c√≥digo

#### for

El bucle for recibe

- un contador, generalmente llamado i de √≠ndice
- un l√≠mite, que hace de condici√≥n de salida del bucle
- la actualizaci√≥n del contador al final de cada iteraci√≥n

```js
const mensaje = 'Hola, estoy dentro de un bucle';

for (let i = 0; i < 5; i++) {
  console.log(mensaje, `en la vuelta ${i + 1}`);
}
```

Las iteraciones son usadas con frecuencia para recorres estructuras iterables, como los strings y sobre todo los **arrays**

```js
const weekDays = [
  'Lunes',
  'Martes',
  'Mi√©rcoles',
  'Jueves',
  'Viernes',
  'S√°bado',
  'Domingo',
];

for (let i = 0; i < weekDays.length; i++) {
  console.log(weekDays[i]);
}

for (let i = weekDays.length - 1; i >= 0; i--) {
  console.log(weekDays[i]);
}
```

#### for of

[_üóìÔ∏èES2015_]

Es una variante del bucle for que apareci√≥ en ES6 y, de alguna manera, oculta su implementaci√≥n, creando una variable (iterator) que va tomando sucesivamente el valor de cada uno de los items del array.

Podr√≠a decirse que es el equivalente del m√©todo foreach de los arrays.

```js
const accumulate = (data) => {
  let accumulator = 0;
  for (const iterator of numbers) {
    console.log(iterator);
    accumulator += iterator;
  }
  return accumulator;
};

const numbers = [1, 2, 3, 4, 5, 6];

console.log('El total es', accumulate(numbers)); // 21
```

#### for in

Esta estructura permite recorrer un objeto, que en si no es iterable, obteniendo cada una de las claves o identificadores de las propiedades.
A partir de ah√≠, gracias a la notaci√≥n [], se puede obtener cada uno de los correspondientes valores.

```js
const showObject = (obj) => {
  for (const key in obj) {
    const value = obj[key];
    console.log(`La propiedad '${key}' vale ${value}`);
  }
};

const user = {
  name: 'Pepe',
  age: 22,
  course: 'Angular',
};
showObject(user);
```

Otra forma de permitir la iteraci√≥n en objetos es convertirlos primero en arrays de pares clave valor, usando para ello el m√©todo Object.entries

```js
const showObject = (obj) => {
  const entries = Object.entries(obj);

  for (const [key, value] of entries) {
    console.log(`La propiedad '${key}' vale ${value}`);
  }
};

const user = {
  name: 'Pepe',
  age: 22,
  course: 'Angular',
};
showObject(user);
```

El bucle for in tambi√©n puede aplicarse a un array, siendo en ese caso el indice del item lo que se recibe como key en cada una de las iteraciones, aunque sin garantizar que se respete el orden de los √≠ndices num√©ricos, por lo que este bucle no suele usarse con arrays.

```js
const accumulate = (data) => {
  let accumulator = 0;
  for (const i in numbers) {
    console.log(data[i]);
    accumulator += data[i];
  }
  return accumulator;
};

const numbers = [10, 20, 30, 40, 50, 60];

console.log('El total es', accumulate(numbers));
```

#### sentencias break y continue

Permiten manipular el comportamiento normal de los bucles for, for-in y for-of

- break permite terminar de forma abrupta un bucle
- continue permite saltarse una repetici√≥n del bucle, pasando a la siguiente.

```js
const useBreak = (text) => {
  let result = '';
  for (const item of text) {
    if (item === 'a') {
      break;
    }
    result += item;
  }
  return result;
};
const useContinue = (text) => {
  let result = '';
  for (const i in text) {
    if (text[i] == 'a') {
      continue;
    }
    result += text[i];
  }
  return result;
};

const text = 'En un lugar de la Mancha...';
console.log(useBreak(text)); // En un lug
console.log(useContinue(text)); // En un lugr de l Mnch...
```

### Iteraciones condicionales

Las iteraciones se ejecutan siempre que se siga cumpliendo la condici√≥n evaluada a partir de una expresi√≥n condicional

#### do

La expresi√≥n condicional en previa a las iteraciones:
el bucle se ejecutan ninguna o m√°s veces, dependiendo de la condici√≥n indicada

```js
let resultado = 1;
let numero = 5;
do {
  resultado *= numero;
  numero--;
} while (numero > 0);

console.log(resultado); // 120
```

#### while

La expresi√≥n condicional es posterior a cada una de las iteraciones:
el bucle se ejecutan una o m√°s veces, ya que lo hace al menos la primera vez.

```js
let resultado = 0;
const numero = 100;
let i = 0;
while (i <= numero) {
  resultado += i;
  i++;
}
console.log(resultado); // 5050
```

### Control de excepciones (errores)

Los errores o excepciones son las situaciones que el interprete (engine) de JavaScrip no puede resolver, por lo que interrumpe la ejecuci√≥n del c√≥digo y muestra en consola la informaci√≥n correspondiente al error.

```js
// La funci√≥n no existe
foo();

// foo();
// ^
// ReferenceError: foo is not defined
//     at file:///c:/Desarrollo/SkyLab/bootcamp-2023-07-mad/learn-JS/7-make-error.js:2:1
//     at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
```

Las gesti√≥n de errores o excepciones permite evitar que estas acaben descontroladas poniendo fin a la ejecuci√≥n del programa. Para ello se utiliza la estructura try-catch

```js
try {
  // La funci√≥n no existe
  foo();
} catch (error) {
  console.log(error.name); // ReferenceError
  console.log(error.message); // foo is not defined
}
console.log('Fin del programa'); // Fin del programa
```

La instrucci√≥n **try** delimita un bloque de c√≥digo y captura cualquier error o excepci√≥n que se produzca, almacen√°ndola en memoria para pas√°rsela a la clausula catch .

La clausula **catch** define un par√°metro de tipo **objeto Error** que recoger√° los datos de la excepci√≥n.
Estos objetos incluyen las propiedades name, message y stack

#### Excepciones provocadas

La instrucci√≥n **throw** permite desencadenar (raise) una excepci√≥n en respuesta a cualquier circunstancia elegida por el desarrollador

throw va seguido de una expresi√≥n que puede debe ser un **objeto Error**, creado como new Error() con el mensaje del error como par√°metro, aunque tambi√©n podr√≠a ser

- un literal con el mensaje del error
- un objeto literal con el nombre del error y el correspondiente mensaje

La excepci√≥n desencadenada se comporta igual que cualquier error de javaScript, por lo que debe encontrarse dentro de un bloque try, para pasar el control a la clausula catch, qhe recibir√° como para¬¥metro el objeto error

```js
const validateNumber = (x) => {
  if (x == '') throw new Error('empty');
  if (isNaN(x)) throw new Error('not a number');
  if (x > 10) throw new Error('too high');
  if (x < 5) throw new Error('too low');
  return x;
};

try {
  console.log(validateNumber(10)); // 10
  console.log(validateNumber(11)); // Error: too high
} catch (error) {
  console.log('Error:', error.message);
}
```

## M√≥dulos

[_üóìÔ∏èES2015_]

En ES6 se incorpora un nuevo formato de m√≥dulos ESM, que viene a sustituir al formato CommonJS Module, utilizado por algunas aplicaciones como Node.

Para usarlo en **HTML** es necesario indicar el **type=module** del script

```html
  <script src="index.js" type="module">
```

Para usarlo en **Node** es necesario indicar el **type=module** en el fichero de configuraci√≥n del proyecto, **package.json**

```json
//package.json
{
  "type": "module"
}
```

Los m√≥dulos son archivos que exportan funciones (y/o variables).
Los elementos exportados pueden serlo de dos formas

- por defecto (sin nombre) se puede exportar un s√≥lo elemento
- por su nombre se pueden exportar todos los elementos deseados
- los elementos de uso interno del m√≥dulo no se exportan

```js
export const foo1 = () => {
  fooInternal();
  console.log('Soy foo1');
};

export const foo2 = () => {
  fooInternal();
  console.log('Soy foo2');
};

export const foo3 = () => {
  console.log('Soy foo3');
};

const fooInternal = () => {
  console.log('Soy fooInternal');
};

export default foo1;
```

Los m√≥dulos pueden ser **importados** en otros m√≥dulos que necesitan hacer uso de su funcionalidad

Al igual que en la exportaci√≥n, hay dos tipos de import:

- Sin nombre, importa lo exportado por defecto
- Con nombre, importa lo exportado con nombre

```js
import foo1, { foo2, foo3 } from './5-module.js';

foo1();
foo2();
foo3();
// Soy fooInternal
// Soy foo1
// Soy fooInternal
// Soy foo2
// Soy foo3
```

### Importaci√≥n din√°mica

[_üóìÔ∏èES2020_]: dynamic import

Inicialmente los ESModules s√≥lo pod√≠an ser importados est√°ticamente, al inicio de la carga de otros m√≥dulos.

M√°s adelante aparece la posibilidad de hacerlo din√°micamente: en cualquier punto del c√≥digo, al hacerse necesaria una funcionalidad de otro m√≥dulo, se puede ejecutar la funci√≥n `import()` que realizara la importaci√≥n

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic ESM Sample</title>
  </head>

  <body>
    <nav>
      <a href="books.html" data-src-module="books">Books</a>
      <a href="movies.html" data-src-module="movies">Movies</a>
      <a href="games.html" data-src-module="games">Video Games</a>
    </nav>

    <main>Content will load here!</main>

    <script>
      const main = document.querySelector('main');
      const menuLinks = document.querySelectorAll('nav > a');
      const handleClick = async (event) => {
        event.preventDefault();
        const link = event.target;
        try {
          const module = await import(
            `./section-modules/${link.dataset.srcModule}.js`
          );
          module.loadPageInto(main);
        } catch (error) {
          main.innerHTML = `<p class="error">${error.message}</p>`;
        }
      };

      for (const link of menuLinks) {
        link.addEventListener('click', handleClick);
      }
    </script>
  </body>
</html>
```

En este ejemplo la carga de los m√≥dulos esta siendo 'lazy', ya que s√≥lo se produce la primera vez que son requeridos en respuesta a la interacci√≥n del usuario con el menu.

### Metadatos de los m√≥dulos

[_üóìÔ∏èES2020_]

El objeto import.meta tiene la propiedad url indicando la URL base del m√≥dulo. Esta ser√°:

- la URL de la que el script fue obtenido, por scripts externos, o
- la URL base del documento que contiene el documento, por scripts inline.

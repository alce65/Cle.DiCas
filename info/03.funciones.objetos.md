# Funciones y objetos

## ndice

- [Funciones y objetos](#funciones-y-objetos)
  - [ndice](#铆ndice)
  - [Funciones](#funciones)
    - [Creaci贸n y uso](#creaci贸n-y-uso)
      - [Declaraci贸n v. asignaci贸n](#declaraci贸n-v-asignaci贸n)
      - [Ejecuci贸n, invocaci贸n o llamada](#ejecuci贸n-invocaci贸n-o-llamada)
      - [Re-asignaci贸n](#re-asignaci贸n)
      - [Hoisting](#hoisting)
    - [mbito (scope) de las variables](#谩mbito-scope-de-las-variables)
    - [Par谩metros v. argumentos](#par谩metros-v-argumentos)
      - [Argumentos de tipo primitivo](#argumentos-de-tipo-primitivo)
      - [Argumentos de tipo referenciado](#argumentos-de-tipo-referenciado)
  - [Des-estructuraci贸n (Destructuring)](#des-estructuraci贸n-destructuring)
    - [Des-estructuraci贸n en la declaraci贸n de variables](#des-estructuraci贸n-en-la-declaraci贸n-de-variables)
    - [Des-estructuraci贸n en la declaraci贸n de par谩metros](#des-estructuraci贸n-en-la-declaraci贸n-de-par谩metros)
    - [Operador spread (extendido)](#operador-spread-extendido)
      - [Deep clone](#deep-clone)
    - [Operador rest](#operador-rest)
  - [Objetos](#objetos)
    - [Creaci贸n y tipos de objetos](#creaci贸n-y-tipos-de-objetos)
      - [Objetos literales](#objetos-literales)
      - [Objetos literales y prototipos](#objetos-literales-y-prototipos)
      - [Objetos construidos o instancias](#objetos-construidos-o-instancias)
    - [Propiedades de los objetos](#propiedades-de-los-objetos)
      - [Niveles](#niveles)
        - [Anidamiento y propiedades undefined](#anidamiento-y-propiedades-undefined)
        - [Anidamiento y clonaci贸n](#anidamiento-y-clonaci贸n)
      - [Iteraciones](#iteraciones)
      - [Propiedades del prototipo](#propiedades-del-prototipo)
    - [Car谩cter funcional: funciones como objetos](#car谩cter-funcional-funciones-como-objetos)
      - [Funciones con propiedades 'extra'](#funciones-con-propiedades-extra)
      - [Funciones anidadas](#funciones-anidadas)
      - [Funciones de orden superior y callbacks](#funciones-de-orden-superior-y-callbacks)
      - [Funciones auto-invocadas](#funciones-auto-invocadas)
      - [Closures](#closures)
  - [Paradigma funcional: funciones como objetos](#paradigma-funcional-funciones-como-objetos)
    - [Funciones con propiedades 'extra'](#funciones-con-propiedades-extra-1)
    - [Funciones anidadas](#funciones-anidadas-1)
    - [Funciones de orden superior y callbacks](#funciones-de-orden-superior-y-callbacks-1)
    - [Funciones auto-invocadas](#funciones-auto-invocadas-1)
    - [Closures](#closures-1)
  - [Paradigma de orientaci贸n a objetos: clases](#paradigma-de-orientaci贸n-a-objetos-clases)

## Funciones

Son conjuntos de instrucciones,
generalmente asociados a un **identificador**,
gracias a lo cual pueden ser **invocadas** (ejecutadas)
con su propio espacio de memoria (**scope**)
En todos los casos, cuando concluyen la ejecuci贸n,
**retornan** (devuelven) un valor.
Si este es undefined la funci贸n se considera de tipo **void**.

### Creaci贸n y uso

En JS las funciones son tambi茅n valores y su tipo es el de **objetos 'de pleno derecho**.
Esto determina que ademas de declararlas, sea posible asignarlas a una variable, como sucede con cualquier valor (incluidos los de tipo objeto)

#### Declaraci贸n v. asignaci贸n

Se pueden crear funcione mediante **declaraci贸n**

En ella se incluye la implementaci贸n (cuerpo de la funci贸n): el conjunto de funciones que ser谩 ejecutado.

```js
function foo() {
  // Implementaci贸n
  console.log('Soy foo');
}
```

la alternativa es la **asignaci贸n** de una expresi贸n functional (function expression) o funci贸n an贸nima a una variable

```js
const bar = function () {
  // Implementaci贸n
};
```

En ES6, la expresi贸n funcional puede escribirse como **arrow function** [_锔ES2015_]

```js
const arrow = () => {
  // Implementaci贸n
};
```

Cuando las arrow functions son de una sola l铆nea que directamente retorna una expresi贸n, pueden omitirse las llaves ({}) y el return

```js
const add = (a, b) => a + b;
```

Las arrow functions usan un **lexical scope**, a diferencia del **dynamic scope** de las funciones habituales.

Eso obliga a tener en cuenta algunas limitaciones en su uso

- no suelen usarse como **m茅todos**, ya que si lo son, no tendr谩n acceso al objeto mediante `this` ni al padre como `super`
- no pueden usarse como funciones **constructoras**
- no pueden usarse como **generadores** porque en su implementaci贸n no pueden usar el operador `yield`

#### Ejecuci贸n, invocaci贸n o llamada

Cualquiera que sea la forma en que se a creado, la funci贸n se invoca o ejecuta usando su identificador + el **operador de invocaci贸n**, los par茅ntesis

```js
identificador();
```

En ese momento, js crea un nuevo entorno de ejecuci贸n (**execution scope**) en el que existen las variables locales de la funci贸n (incluidos los par谩metros)

Cuando la ejecuci贸n concluye, la funci贸n devuelve el valor que corresponda (puede ser undefined), y el entorno de ejecuci贸n desaparece, con todas las variables locales que incluya

#### Re-asignaci贸n

Usando el identificador de una funci贸n, sin el operador de invocaci贸n (los par茅ntesis), puede asignarse su valor a otra variable.

Tendremos as铆 dos identificadores diferentes que hacen referencia a una misma funci贸n (bloque de c贸digo)

```js
const countWeekDays = function () {
  return 7;
};

const weekDays = countWeekDays;
console.log(weekDays);

console.log(countWeekDays());
console.log(weekDays());
```

#### Hoisting

La llamada (o invocaci贸n) a la funci贸n declarada como funci贸n puede ser anterior a su declaraci贸n.
Esto se debe al proceso conocido como alzamiento (**hoisting**) o visibilidad sint谩ctica: las declaraciones de variables con var y las funciones declaradas con function son alzadas al principio por el interprete de JS

```js
foo(); // Ejemplo de Hoisting
// ReferenceError bar();
// ReferenceError arrow();

function foo() {
  // Implementaci贸n
}

const bar = function () {
  // Implementaci贸n
};

const arrow = () => {
  // Implementaci贸n
};
```

Cuando una funci贸n se crea mediante asignaci贸n a una variable, el proceso de alzamiento no se produce

### mbito (scope) de las variables

Las variables declaradas directamente fuera de cualquier funci贸n tienen un 谩mbito global o del m贸dulo en que existen.

Las variables declaradas como par谩metros o dentro de una funci贸n tienen un 谩mbito local a la funci贸n.

- no pueden ser accedidas desde fuera de la funci贸n
- desaparecen cuando concluye la ejecuci贸n de la funci贸n

Cuando el identificador de una variable local es el mismo que el de una de 谩mbito (scope) superior, ensombrece (shadow) a esta 煤ltima, de modo que no puede ser accedida.

```js
let text1 = 'Valor inicial';
let text2 = 'Valor inicial';

function foo() {
  var text1;
  text1 = 'Cambio desde dentro';
  text2 = 'Cambio desde dentro';
}

foo();
console.log(text1); // "Valor inicial"
console.log(text2); // "Cambio desde dentro
```

Al contrario de lo que sucede en el ejemplo, una funci贸n **no debe** acceder a las variables globales, para evitar que quede **acoplada** al c贸digo principal

### Par谩metros v. argumentos

Al invocar una funci贸n se incluyen los **argumentos** (tambi茅n denominados par谩metros reales) necesarios: valores obtenidos al evaluar la expresi贸n que se env铆an a la funci贸n

La funci贸n recibe esos valores en variable locales denominadas **par谩metros** (o par谩metros formales) que se utilizan como parte de las operaciones llevadas a cabo en el cuerpo (implementaci贸n) de la funci贸n.

```js
const add = (x, y) => {
  const r = x + y;
  return r;
};
```

La funci贸n tiene 3 variable locales:
r y los par谩metros x e y, que se inicializar谩n con los valores recibidos como argumentos.

```js
const x = 5;
console.log('Add', add(x)); // NaN
console.log('Add', add(x, 4)); // 9
console.log('Add', add(x, 4, 8)); // 9
```

La funci贸n se invoca con diferente n煤mero de argumentos

- si hay menos argumentos que par谩metros, los que no reciben argumento se inicializan con valor undefined
- si hay m谩s argumentos que par谩metros, los que sobran se ignoran

En ES6 es f谩cil definir los **valores por defecto**, de los par谩metros, de forma que se inicialicen con esos valores en caso de no recibir ning煤n valor como argumento

```js
const add = (x = 0, y = 0) => {
  const r = x + y;
  return r;
};

const x = 5;
console.log('Add', add()); // 0
console.log('Add', add(x)); // 5
```

En VSC los valores por defecto se utilizan para inferir el tipo de los par谩metros, aunque ello no signifique que se fija ese tipo, como ocurrir铆a en TypeScript

#### Argumentos de tipo primitivo

Si los argumentos son valores primitivos, lo que reciben los par谩metros es el **valor**.

La funci贸n nunca cambia el valor de la variable que se usa como argumento, a no ser que la manipule directamente y esto 煤ltimo no deber铆a ocurrir nunca.

```js
const foo = (x) => {
  x = x + 1;
  console.log('Valor de x local a foo', x); // 3
  return x;
};

const x = 2;
console.log('Valor inicial de x global', x); // 2
foo(x);
console.log('Valor finas de x global', x); // 2
```

#### Argumentos de tipo referenciado

Si los argumentos son objetos (valores primitivos), lo que reciben los par谩metros es la **referencia** a la instancia del objeto.

Si la funci贸n **muta el objeto**, el cambio afecta a la instancia original, que es la 煤nica que existe

```js
const foo = (x) => {
  x.user = 'Juan';
  console.log('Valor de x local a foo', x); //  { user: 'Juan' }
  return x;
};

const x = { user: 'Pepe' };
console.log('Valor inicial de x global', x); //  { user: 'Pepe' }
foo(x);
console.log('Valor finas de x global', x); //  { user: 'Juan' }
```

## Des-estructuraci贸n (Destructuring)

[_锔ES2015_]

En el proceso de declaraci贸n de las variables y par谩metros, si el valor asignado es un objeto (o array), pueden recogerse por separado sus propiedades o items en variables completamente independientes

### Des-estructuraci贸n en la declaraci贸n de variables

```js
const createArray = () => [1, 2];
const createObject = () => ({
  name: 'Pepe',
  age: 22,
});

const [first, second] = createArray();
const { name, age } = createObject();

console.log(first, second);
console.log(name, age);
```

### Des-estructuraci贸n en la declaraci贸n de par谩metros

```js
const useArray = ([first, second]) => {
  console.log(first);
  console.log(second);
};

useArray([1, 2]);

const useObject = ({ name, age }) => {
  console.log(name);
  console.log(age);
};

useObject({
  name: 'Pepe',
  age: 22,
});
```

### Operador spread (extendido)

Permite la expansi贸n de iterables (arrays y strings) y objetos

- un iterable (arrays y strings) puede ser expandido
  - en llamadas de funci贸n con cero o m谩s argumentos esperados
  - en arrays literales, donde se esperan nuevos elementos

```js
const addTwoNumbers = (a, b) => a + b;
const numbers = [1, 2];
const numbersB = [...numbers];

console.log(numbersB); // [1,2]

const result = addTwoNumbers(...numbers);

console.log(result); // 3
```

- un objeto puede ser expandido en lugares donde son esperados cero o m谩s pares de valores clave (para literales tipo Objeto) [_锔ES2018_]

```js
const obj = { name: 'Pepe', age: 22 };
const objB = { ...obj, age: 23 };

console.log(objB); // { name: 'Pepe', age: 23 }
```

El spread operator se convierte as铆 en un mecanismo para la clonaci贸n de objetos (incluidos arrays): obtener una nueva instancia con las mismas propiedades o incluso con la mutaci贸n de algunas

Este mecanismo no afecta a niveles anidados, es decir a arrays de arrays o propiedades de tipo objeto

#### Deep clone

Para conseguir un deep clone pueden usarse 2 t茅cnicas

- uso de los m茅todos est谩ticos de JSON (stringify y parse)
- uso del la nueva funci贸n global structuredClone incluida en las APIs del browser y node (desde su versi贸n 11)

```js
const user = {
  name: {
    firstName: 'Pepe',
    surname: 'Perez',
  },
  age: 22,
};

const userB = JSON.parse(JSON.stringify(user));
console.log(userB);

const userC = structuredClone(userB);
console.log(userC);
```

### Operador rest

El operador rest al usarse en la sintaxis de los par谩metros de una funci贸n le permite recibir un n煤mero indefinido de argumentos como un array, permitiendo as铆 representar funciones 'variadicas' (variadic functions) en JavaScript

```js
const sumNumbers = (...numbers) => {
  let accumulator = 0;
  for (const iterator of numbers) {
    accumulator += iterator;
  }
  return accumulator;
};

console.log(sumNumbers(2, 5, 3, 5, 2, 7, 7)); // 31
```

Tambi茅n puede emplearse el operador rest como parte del proceso de des-estructuraci贸n

```js
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...others] = numbers;
console.log(others); // [ 3, 4, 5 ]
```

Est茅 煤ltimo caso puede igualmente ocurrir con objetos [_锔ES2018_]

```js
const { first, second, ...others } = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5,
};

console.log(first); // 1
console.log(second); // 2
console.log(others); // { third: 3, fourth: 4, fifth: 5 }
```

## Objetos

### Creaci贸n y tipos de objetos

- Datos de tipo referenciado
- Incluyen propiedades que a su vez corresponden a dato de cualquier tipo: primitivos, objetos o funciones
  - En el caso de los arrays, los identificadores de las propiedades son indices num茅ricos que permiten la iteraci贸n a lo largo del array

Cuando una propiedad es de tipo funci贸n se denomina m茅todo.

- Acceden de forma transparente al objeto al que apunta la propiedad "**proto**". Este suele ser el prototype de la funci贸n constructora del objeto. De esta forma se aplica el **patr贸n prototype** para conseguir una relaci贸n entre objetos asimilable a las **clases** de otros lenguajes de programaci贸n

Los objetos pueden declararse:

- literalmente
- con el patron constructor

#### Objetos literales

JS permite crear de forma literal objetos, arrays y expresiones regulares (RegExp),
todos ellos variaciones del tipo **object**

```js
const user = {
  name: 'Pepe',
  age: 22,
};

// Array
const numbers = [1, 2, 3, 4];

// Regular Expression (RegExp)
const regExp = /a/i;

console.log(user); // { name: 'Pepe', age: 22 }
console.log(numbers); // [ 1, 2, 3, 4 ]
console.log(regExp); // /a/i
```

Esta forma de notaci贸n se conoce con **JavaScrip Object Notation (JSON)** y ha dado lugar a un formato de **ficheros, json**, convertido pr谩cticamente en el est谩ndar de intercambio de datos entre distintas capas de software (servidores, clientes...)

- se utilizan siempre dobles comillas (")
- las claves o propiedades siempre van entre comillas, al igual que los valores de tipo string

El formato literal es solo una notaci贸n.
Los objetos obtenidos son exactamente los mismos que los que resultar铆an del patron constructor: instancias de la misma funci贸n constructora y con el mismo prototipo, del que pueden tomar las propiedades comunes a todas las instancias de dicha funci贸n constructora (clase)

```js
const user = {
  name: 'Pepe',
  age: 22,
};

// Array
const numbers = [1, 2, 3, 4];

// Regular Expression (RegExp)
const regExp = /a/i;

console.log(user);
console.log(user.constructor); // [Function: Object]
console.log(Object.getPrototypeOf(user)); // [Object: null prototype] {}
console.log(user instanceof Object); // true

console.log(numbers);
console.log(numbers.constructor); // [Function: Array]
console.log(Object.getPrototypeOf(numbers)); // Object(0) []
console.log(numbers instanceof Object); // true
console.log(numbers instanceof Array); // true

console.log(regExp);
console.log(regExp.constructor); // [Function: RegExp]
console.log(Object.getPrototypeOf(regExp)); // {}
console.log(regExp instanceof Object); // true
console.log(regExp instanceof RegExp); // true
```

#### Objetos literales y prototipos

Se puede crear un objeto literal que tenga como prototipo (**proto**) cualquier otro objeto

```js
const organization = {
  brand: 'ISDI',
};

const user = Object.create(organization);

user.name = 'Pepe';
user.age = 22;

console.log(user);
console.log(user.brand);
```

De esa forma el nuevo objeto podr谩 acceder de forma transparenta a las propiedades de su prototipo, siempre que no existan en el mismo objeto

#### Objetos construidos o instancias

Desde la aparici贸n de JS, Los objetos pueden crearse como nuevas **instancias** resultantes de emplear el patron constructor (new) con una **funci贸n constructora**, de forma similar a como otros lenguajes utilizan las clases.

A partir de ES6, comienza a usarse la palabra reservada **class** y se habla de **clases** para referirse al proceso antes mencionado, de creaci贸n de instancias a partir de funciones constructoras (ahora con apariencia de clases)

```js
const user = new Object({
  name: 'Pepe',
  age: 22,
});

console.log(user); // { name: 'Pepe', age: 22 }

// Array
const numbers = new Array(1, 2, 3, 4);
console.log(numbers); // [ 1, 2, 3, 4 ]

// Regular Expression (RegExp)
const regExp = new RegExp(/a/i);
console.log('RegExp new', regExp); // /a/i

// Date
const date = new Date();
console.log(date); // 2023-08-19T11:56:56.079Z

// Error
const error = new Error('Some error');
console.log(error); // Error: Some error
```

### Propiedades de los objetos

Cualquiera que sea la forma en que se han creado, los objetos tienen propiedades a las que se puede acceder mediante dos formas de notaci贸n

- puntos (dot notation)
- corchetes (bracket notation)

```js
{
  const user = {
    name: 'Pepe',
  };
  console.log(user['name']); // Pepe

  const property = 'name';
  console.log(user[property]); // Pepe
}
```

La notaci贸n de corchetes solo se utiliza si el **nombre de la propiedad** es una **variable**, que debe ser evaluada para luego acceder a la propiedad correspondiente al valor de la variable

Con ambas notaciones es posible leer, modificar crear y eliminar propiedades.

```js
const obj = {
  name: 'Pepe',
  age: 22,
};
// A帽adimos propiedades
obj.lastName = 'Perez';
// Modificamos propiedades
obj.name = 'Jose';
// Eliminamos propiedades
delete obj.age;
console.log(obj);
```

Todos estos cambios se enmarcan en el concepto de **mutabilidad** de los objetos

#### Niveles

Las propiedades de los objetos pueden ser otros objetos, dando lugar a tantos niveles de anidamiento o profundidad como sea necesario.

As铆 se refleja tanto en su creaci贸n como en el acceso a las propiedades en cualquiera de las notaciones.

```js
const user = {
  name: {
    firstName: 'Pepe',
    surname: 'Perez',
  },
};
user.address = {};
user.address.street = 'c/ del Pez';
user['address'].number = '22 3陋 C';
user['address']['city'] = 'Teruel';

console.log(user);
// { name: { firstName: 'Pepe', surname: 'Perez' },
// address: { street: 'c/ del Pez', number: '22 3陋 C', city: 'Teruel' } }
```

##### Anidamiento y propiedades undefined

Si se accede a cualquier propiedad de un objeto que no existe, el valor devuelto es undefined

Sin embargo si se intenta acceder a una propiedad de una propiedad que no existe, de desencadena un TypeError.

Para evitarlo puede usarse el operador **optional chaining** (?.), que no continua a un siguiente nivel de anidamiento cuando obtiene un undefined o null en el anterior, devolviendo en ese caso un undefined

```js
const obj = {
  name: 'Pepe',
  age: 22,
};
console.log(obj.address); // undefined
try {
  console.log(obj.address.city);
} catch (error) {
  console.log(error.name); // TypeError
  console.log(error.message); // Cannot read properties of undefined (reading 'city')
}
console.log(obj.address?.city); // undefined
```

##### Anidamiento y clonaci贸n

Este posible anidamiento debe tenerse en cuenta al plantear el proceso de clonaci贸n o deep copy de un objeto, consistente en crear una instancia nueva.

Algunas de las formas de obtener este resultado no lo hacen en profundidad, y solo crean una shallow copy de las estructuras anidadas:

- Object.assign()
- {...Object}

Existen otras alternativas que si crean una deep copy a todos los niveles:

- JSON.parse(JSON.stringify(object))
- structuredClone()

#### Iteraciones

Los objetos no son iterables, como arrays y strings, por lo que no pueden recorrerse en base a un 铆ndice num茅rico, como hacen for y for-of.

Las iteraciones en los objetos de JS pueden realizarse con la estructura for-in, que ya conocemos.

#### Propiedades del prototipo

El prototipo de los objetos incluye una serie de propiedades y m茅todos accesibles de forma transparente por todos los objetos, que en general no se utilizan demasiado

```js
const obj = new Object({
  name: 'Pepe',
  age: 22,
});

console.log(obj.constructor);
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.isPrototypeOf({})); // false
console.log(obj.propertyIsEnumerable('name')); // true
console.log(obj.toString()); // [object Object]
console.log(obj.toLocaleString()); // [object Object]
console.log(obj.valueOf()); // { name: 'Pepe', age: 22 }
```

### Car谩cter funcional: funciones como objetos

Ya sabemos que en JS las funciones son tambi茅n valores y su tipo es el de **objetos 'de pleno derecho**.

Entre otras cosas

- pueden tener propiedades
- pueden ser asignadas a una variable
- pueden ser incluidas (anidadas) en otra funci贸n
- pueden ser recibidas como par谩metros
- pueden ser devueltas por otra funci贸n

#### Funciones con propiedades 'extra'

Aunque no suele hacerse, una funci贸n puede tener propiedades como cualquier otro objeto

```js
const foo = () => {
  console.log('Soy foo');
};

foo.date = new Date();

console.log(foo);
// [Function: foo] { date: 2023-08-16T11:23:04.205Z }
```

#### Funciones anidadas

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }

  return square(a) + square(b);
}

console.log(addSquares(4, 5)); // 41
```

La funci贸n 'interna' square solo existe en el scope de la otra y solo puede ser utilizada dentro de ella

#### Funciones de orden superior y callbacks

Una funci贸n de orden superior (**hight order function**) es la que

- recibe una funci贸n como par谩metro
- devuelve una funci贸n

La funci贸n recibida como par谩metro se denomina **callback**

```js
const hof = (callback) => {
  console.log(callback());
};

hof(() => 'Soy un callback');
```

Los callback pueden ser indistintamente funciones con nombre o an贸nimas, aunque esta segunda opci贸n es muy habitual, como lo es en ese caso el uso de las arrow functions

Entre los usos m谩s habituales de los callbacks:

- permitir asignar funciones como manejadores de eventos as铆ncronos
- asignar funciones a timeouts, como otra forma de asincron铆a

#### Funciones auto-invocadas

Despu茅s de la declaraci贸n de una funci贸n an贸nima (expresi贸n funcional), es posible que 茅sta se invoque a si misma para ser ejecutada inmediatamente

El patr贸n de esta pr谩ctica se denomina IIFE (**Immediately Invoked Function Expression**)

```js
(() => {
  console.log('Ejemplo de una IIFE');
})();
```

La creaci贸n de su propio espacio de memoria en las funciones hace que se puedan utilizar para aislar un c贸digo fuente y evitar colisiones de variables o espacios de nombres en general: El c贸digo se ejecuta directamente, como si no hubiera funci贸n, pero en su propio espacio de memoria

#### Closures

Una funci贸n que encapsula un conjunto de definiciones locales :

- variables,
- otras funciones (por extensi贸n objetos).

Se basa por tanto en el anidamiento de funciones.

- permite que la funci贸n interna "escape" de la funci贸n padre: se hace accesible desde fuera
- la funci贸n interna sigue teniendo acceso al 谩mbito (scope) de la funci贸n padre despu茅s de que 茅sta haya retornado

El 谩mbito de visibilidad de la funci贸n externa se utiliza para crear el equivalente a un m贸dulo

Las funciones internas pueden ser setters y getters de variables locales, no accesibles directamente desde fuera

Se pueden utilizar varios patrones para conseguir un closure:

- una funci贸n incluye una funci贸n interna y la devuelve
- una funci贸n incluye una funci贸n interna y se la asigna a una variable del nivel superior

```js
const closureCount = () => {
  let counter = 0;
  return () => counter++;
};

const extCounter = closureCount();

console.log(extCounter()); // 0
console.log(extCounter()); // 1
console.log(extCounter()); // 2
```

En el primero de los patrones puede a帽adirse una IIFE

```js
const closureCount = (() => {
  let counter = 0;
  return () => counter++;
})();

console.log(closureCount()); // 0
console.log(closureCount()); // 1
console.log(closureCount()); // 2
```

## Paradigma funcional: funciones como objetos

Ya sabemos que en JS las funciones son tambi茅n valores y su tipo es el de **objetos 'de pleno derecho**.

Entre otras cosas

- pueden tener propiedades
- pueden ser asignadas a una variable
- pueden ser incluidas (anidadas) en otra funci贸n
- pueden ser recibidas como par谩metros
- pueden ser devueltas por otra funci贸n

### Funciones con propiedades 'extra'

Aunque no suele hacerse, una funci贸n puede tener propiedades como cualquier otro objeto

```js
const foo = () => {
  console.log('Soy foo');
};

foo.date = new Date();

console.log(foo);
// [Function: foo] { date: 2023-08-16T11:23:04.205Z }
```

### Funciones anidadas

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }

  return square(a) + square(b);
}

console.log(addSquares(4, 5)); // 41
```

La funci贸n 'interna' square solo existe en el scope de la otra y solo puede ser utilizada dentro de ella

### Funciones de orden superior y callbacks

Una funci贸n de orden superior (**hight order function**) es la que

- recibe una funci贸n como par谩metro
- devuelve una funci贸n

La funci贸n recibida como par谩metro se denomina **callback**

```js
const hof = (callback) => {
  console.log(callback());
};

hof(() => 'Soy un callback');
```

Los callback pueden ser indistintamente funciones con nombre o an贸nimas, aunque esta segunda opci贸n es muy habitual, como lo es en ese caso el uso de las arrow functions

Entre los usos m谩s habituales de los callbacks:

- permitir asignar funciones como manejadores de eventos as铆ncronos
- asignar funciones a timeouts, como otra forma de asincron铆a

### Funciones auto-invocadas

Despu茅s de la declaraci贸n de una funci贸n an贸nima (expresi贸n funcional), es posible que 茅sta se invoque a si misma para ser ejecutada inmediatamente

El patr贸n de esta pr谩ctica se denomina IIFE (**Immediately Invoked Function Expression**)

```js
(() => {
  console.log('Ejemplo de una IIFE');
})();
```

La creaci贸n de su propio espacio de memoria en las funciones hace que se puedan utilizar para aislar un c贸digo fuente y evitar colisiones de variables o espacios de nombres en general: El c贸digo se ejecuta directamente, como si no hubiera funci贸n, pero en su propio espacio de memoria

### Closures

Una funci贸n que encapsula un conjunto de definiciones locales :

- variables,
- otras funciones (por extensi贸n objetos).

Se basa por tanto en el anidamiento de funciones.

- permite que la funci贸n interna "escape" de la funci贸n padre: se hace accesible desde fuera
- la funci贸n interna sigue teniendo acceso al 谩mbito (scope) de la funci贸n padre despu茅s de que 茅sta haya retornado

El 谩mbito de visibilidad de la funci贸n externa se utiliza para crear el equivalente a un m贸dulo

Las funciones internas pueden ser setters y getters de variables locales, no accesibles directamente desde fuera

Se pueden utilizar varios patrones para conseguir un closure:

- una funci贸n incluye una funci贸n interna y la devuelve
- una funci贸n incluye una funci贸n interna y se la asigna a una variable del nivel superior

```js
const closureCount = () => {
  let counter = 0;
  return () => counter++;
};

const extCounter = closureCount();

console.log(extCounter()); // 0
console.log(extCounter()); // 1
console.log(extCounter()); // 2
```

En el primero de los patrones puede a帽adirse una IIFE

```js
const closureCount = (() => {
  let counter = 0;
  return () => counter++;
})();

console.log(closureCount()); // 0
console.log(closureCount()); // 1
console.log(closureCount()); // 2
```

## Paradigma de orientaci贸n a objetos: clases

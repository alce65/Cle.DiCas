# Funciones y objetos

## ndice

- [Funciones y objetos](#funciones-y-objetos)
  - [ndice](#铆ndice)
  - [Funciones](#funciones)
    - [Creaci贸n y uso](#creaci贸n-y-uso)
      - [Declaraci贸n v. asignaci贸n](#declaraci贸n-v-asignaci贸n)
      - [Ejecuci贸n, invocaci贸n o llamada](#ejecuci贸n-invocaci贸n-o-llamada)
      - [Re-asignaci贸n](#re-asignaci贸n)
      - [Hoisting](#hoisting)
    - [mbito (scope) de las variables](#谩mbito-scope-de-las-variables)
    - [Par谩metros v. argumentos](#par谩metros-v-argumentos)
      - [Argumentos de tipo primitivo](#argumentos-de-tipo-primitivo)
      - [Argumentos de tipo referenciado](#argumentos-de-tipo-referenciado)
  - [Des-estructuraci贸n (Destructuring)](#des-estructuraci贸n-destructuring)
    - [Des-estructuraci贸n en la declaraci贸n de variables](#des-estructuraci贸n-en-la-declaraci贸n-de-variables)
    - [Des-estructuraci贸n en la asignaci贸n de valores a las variables](#des-estructuraci贸n-en-la-asignaci贸n-de-valores-a-las-variables)
    - [Des-estructuraci贸n en la declaraci贸n de par谩metros](#des-estructuraci贸n-en-la-declaraci贸n-de-par谩metros)
    - [Operador spread (extendido)](#operador-spread-extendido)
      - [Shallow clone (or copy)](#shallow-clone-or-copy)
      - [Deep clone (or copy)](#deep-clone-or-copy)
    - [Operador rest](#operador-rest)
  - [Objetos](#objetos)
    - [Creaci贸n y tipos de objetos](#creaci贸n-y-tipos-de-objetos)
      - [Objetos literales](#objetos-literales)
      - [Objetos construidos](#objetos-construidos)
    - [Propiedades de los objetos](#propiedades-de-los-objetos)
      - [Niveles](#niveles)
        - [Anidamiento y propiedades undefined](#anidamiento-y-propiedades-undefined)
        - [Anidamiento y clonaci贸n](#anidamiento-y-clonaci贸n)
      - [Iteraciones](#iteraciones)
    - [Objetos y prototipos](#objetos-y-prototipos)
      - [Propiedades del prototipo original](#propiedades-del-prototipo-original)
      - [Prototipos y funciones](#prototipos-y-funciones)
      - [Cambiando el prototipos](#cambiando-el-prototipos)
      - [Cadena de prototipos](#cadena-de-prototipos)
  - [Paradigma funcional: funciones como objetos](#paradigma-funcional-funciones-como-objetos)
    - [Funciones con propiedades 'extra'](#funciones-con-propiedades-extra)
    - [Funciones anidadas](#funciones-anidadas)
    - [Funciones de orden superior y callbacks](#funciones-de-orden-superior-y-callbacks)
    - [Funciones auto-invocadas](#funciones-auto-invocadas)
    - [Closures](#closures)
  - [Paradigma de orientaci贸n a objetos: clases](#paradigma-de-orientaci贸n-a-objetos-clases)
    - [Patrones de ejecuci贸n de las funciones](#patrones-de-ejecuci贸n-de-las-funciones)
    - [Funciones constructoras](#funciones-constructoras)
      - [Funciones constructoras y prototipos](#funciones-constructoras-y-prototipos)
      - [M茅todos de instancia y m茅todos de prototipo](#m茅todos-de-instancia-y-m茅todos-de-prototipo)
      - [Propiedades y M茅todos est谩ticos (de "clase")](#propiedades-y-m茅todos-est谩ticos-de-clase)
      - [Herencia](#herencia)
      - [Funciones constructoras nativas de JS](#funciones-constructoras-nativas-de-js)
    - [Clases en ES6](#clases-en-es6)
    - [Accessors: getters y setters](#accessors-getters-y-setters)
    - [JS y la programaci贸n orientada a objetos](#js-y-la-programaci贸n-orientada-a-objetos)

## Funciones

Son

- conjuntos de instrucciones,
- generalmente asociados a un **identificador**,
- gracias a lo cual pueden ser **invocadas** (ejecutadas)
- con su propio espacio de memoria (**scope**)

En todos los casos, cuando concluyen la ejecuci贸n, **retornan** (devuelven) un valor.
Si este es undefined la funci贸n se considera de tipo **void**.

### Creaci贸n y uso

En JS las funciones son tambi茅n valores y su tipo es el de **objetos 'de pleno derecho**.
Esto determina que ademas de declararlas, sea posible asignarlas a una variable, como sucede con cualquier valor (incluidos los de tipo objeto)

#### Declaraci贸n v. asignaci贸n

Se pueden crear funcione mediante **declaraci贸n**

En ella se incluye la implementaci贸n (cuerpo de la funci贸n): el conjunto de funciones que ser谩 ejecutado.

```js
function foo() {
  // Implementaci贸n
  console.log('Soy foo');
}
```

la alternativa es la **asignaci贸n** de una **expresi贸n functional** (function expression) o **funci贸n an贸nima** a una variable

```js
const bar = function () {
  // Implementaci贸n
};
```

En ES6, la expresi贸n funcional puede escribirse como **arrow function** [_锔ES2015_]

```js
const arrow = () => {
  // Implementaci贸n
};
```

Cuando las arrow functions son de una sola l铆nea que directamente retorna una expresi贸n, pueden omitirse las llaves ({}) y el return

```js
const add = (a, b) => a + b;
```

Las arrow functions usan un **lexical scope**, a diferencia del **dynamic scope** de las funciones habituales.

Eso obliga a tener en cuenta algunas limitaciones en su uso

- no suelen usarse como **m茅todos**, ya que si lo son, no tendr谩n acceso al objeto mediante `this` ni al padre como `super`
- no pueden usarse como funciones **constructoras**
- no pueden usarse como **generadores** porque en su implementaci贸n no pueden usar el operador `yield`

#### Ejecuci贸n, invocaci贸n o llamada

Cualquiera que sea la forma en que se a creado, la funci贸n se invoca o ejecuta usando su identificador + el **operador de invocaci贸n**, los par茅ntesis

```js
identificador();
```

En ese momento, js crea un nuevo entorno de ejecuci贸n (**execution scope**) en el que existen las variables locales de la funci贸n (incluidos los par谩metros)

Cuando la ejecuci贸n concluye, la funci贸n devuelve el valor que corresponda (puede ser undefined), y el entorno de ejecuci贸n desaparece, con todas las variables locales que incluya

#### Re-asignaci贸n

Usando el identificador de una funci贸n, sin el operador de invocaci贸n (los par茅ntesis), puede asignarse su valor a otra variable.

Tendremos as铆 dos identificadores diferentes que hacen referencia a una misma funci贸n (bloque de c贸digo)

```js
const countWeekDays = function () {
  return 7;
};

const weekDays = countWeekDays;
console.log(weekDays);

console.log(countWeekDays());
console.log(weekDays());
```

#### Hoisting

La llamada (o invocaci贸n) a la funci贸n declarada como funci贸n puede ser anterior a su declaraci贸n.
Esto se debe al proceso conocido como alzamiento (**hoisting**) o visibilidad sint谩ctica: las declaraciones de variables con var y las funciones declaradas con function son alzadas al principio por el interprete de JS

```js
foo(); // Ejemplo de Hoisting
// ReferenceError bar();
// ReferenceError arrow();

function foo() {
  // Implementaci贸n
}

const bar = function () {
  // Implementaci贸n
};

const arrow = () => {
  // Implementaci贸n
};
```

Cuando una funci贸n se crea mediante asignaci贸n a una variable, el proceso de alzamiento no se produce

### mbito (scope) de las variables

Las variables declaradas directamente fuera de cualquier funci贸n tienen un 谩mbito global o del m贸dulo en que existen.

Las variables declaradas como par谩metros o dentro de una funci贸n tienen un 谩mbito local a la funci贸n.

- no pueden ser accedidas desde fuera de la funci贸n
- desaparecen cuando concluye la ejecuci贸n de la funci贸n

Cuando el identificador de una variable local es el mismo que el de una de 谩mbito (scope) superior, ensombrece (shadow) a esta 煤ltima, de modo que no puede ser accedida.

```js
let text1 = 'Valor inicial';
let text2 = 'Valor inicial';

function foo() {
  var text1;
  text1 = 'Cambio desde dentro';
  text2 = 'Cambio desde dentro';
}

foo();
console.log(text1); // "Valor inicial"
console.log(text2); // "Cambio desde dentro
```

Al contrario de lo que sucede en el ejemplo, una funci贸n **no debe** acceder a las variables globales, para evitar que quede **acoplada** al c贸digo principal

### Par谩metros v. argumentos

Al invocar una funci贸n se incluyen los **argumentos** (tambi茅n denominados par谩metros reales) necesarios: valores obtenidos al evaluar la expresi贸n que se env铆an a la funci贸n

La funci贸n recibe esos valores en variable locales denominadas **par谩metros** (o par谩metros formales) que se utilizan como parte de las operaciones llevadas a cabo en el cuerpo (implementaci贸n) de la funci贸n.

```js
const add = (x, y) => {
  const r = x + y;
  return r;
};
```

La funci贸n tiene 3 variable locales:
r y los par谩metros x e y, que se inicializar谩n con los valores recibidos como argumentos.

```js
const x = 5;
console.log('Add', add(x)); // NaN
console.log('Add', add(x, 4)); // 9
console.log('Add', add(x, 4, 8)); // 9
```

La funci贸n se invoca con diferente n煤mero de argumentos

- si hay menos argumentos que par谩metros, los que no reciben argumento se inicializan con valor undefined
- si hay m谩s argumentos que par谩metros, los que sobran se ignoran

En ES6 es f谩cil definir los **valores por defecto**, de los par谩metros, de forma que se inicialicen con esos valores en caso de no recibir ning煤n valor como argumento

```js
const add = (x = 0, y = 0) => {
  const r = x + y;
  return r;
};

const x = 5;
console.log('Add', add()); // 0
console.log('Add', add(x)); // 5
```

En VSC los valores por defecto se utilizan para inferir el tipo de los par谩metros, aunque ello no signifique que se fija ese tipo, como ocurrir铆a en TypeScript

#### Argumentos de tipo primitivo

Si los argumentos son valores primitivos, lo que reciben los par谩metros es el **valor**.

La funci贸n nunca cambia el valor de la variable que se usa como argumento, a no ser que la manipule directamente y esto 煤ltimo no deber铆a ocurrir nunca.

```js
const foo = (x) => {
  x = x + 1;
  console.log('Valor de x local a foo', x); // 3
  return x;
};

const x = 2;
console.log('Valor inicial de x global', x); // 2
foo(x);
console.log('Valor finas de x global', x); // 2
```

#### Argumentos de tipo referenciado

Si los argumentos son objetos (valores primitivos), lo que reciben los par谩metros es la **referencia** a la instancia del objeto.

Si la funci贸n **muta el objeto**, el cambio afecta a la instancia original, que es la 煤nica que existe

```js
const foo = (x) => {
  x.user = 'Juan';
  console.log('Valor de x local a foo', x); //  { user: 'Juan' }
  return x;
};

const x = { user: 'Pepe' };
console.log('Valor inicial de x global', x); //  { user: 'Pepe' }
foo(x);
console.log('Valor finas de x global', x); //  { user: 'Juan' }
```

## Des-estructuraci贸n (Destructuring)

[_锔ES2015_]

En el proceso de declaraci贸n de las variables y par谩metros, si el valor asignado es un objeto (o array), pueden recogerse por separado sus propiedades o items en variables completamente independientes

### Des-estructuraci贸n en la declaraci贸n de variables

```js
const createArray = () => [1, 2];
const createObject = () => ({
  name: 'Pepe',
  age: 22,
});

const [first, second] = createArray();
const { name, age } = createObject();

console.log(first, second); // 1 2
console.log(name, age); // Pepe 22
```

### Des-estructuraci贸n en la asignaci贸n de valores a las variables

```js
let [first, second] = createArray();
let { name, age } = createObject();

[first, second] = [10, 20];
({ name, age } = { name: 'Jose', age: 30 });

console.log(first, second); // 10 20
console.log(name, age); // Jose 30
```

### Des-estructuraci贸n en la declaraci贸n de par谩metros

```js
const useArray = ([first, second]) => {
  console.log(first);
  console.log(second);
};

useArray([1, 2]);

const useObject = ({ name, age }) => {
  console.log(name);
  console.log(age);
};

useObject({
  name: 'Pepe',
  age: 22,
});
```

### Operador spread (extendido)

Permite la expansi贸n de iterables (arrays y strings) y objetos

- un iterable (arrays y strings) puede ser expandido
  - en llamadas de funci贸n con cero o m谩s argumentos esperados
  - en objetos o arrays literales, donde se esperan nuevos elementos

Su uso en la llamada a una funci贸n permite pasar un n煤mero indefinido de argumentos, extra铆dos a partir de un array

```js
const addTwoNumbers = (a, b) => a + b;
const numbers = [1, 2];
const result = addTwoNumbers(...numbers);

console.log(result); // 3
```

#### Shallow clone (or copy)

En la creaci贸n de arrays literales, el operador spread permite la expansi贸n de un objeto o array en lugares donde se esperan cero o m谩s elementos

```js
const numbers = [1, 2];
const numbersB = [...numbers];
console.log(numbersB); // [1,2]
```

Posteriormente JS a帽adi贸 la posibilidad de expandir un objeto en lugares donde son esperados cero o m谩s pares de valores clave (para literales tipo Objeto) [_锔ES2018_]

```js
const obj = { name: 'Pepe', age: 22 };
const objB = { ...obj, age: 23 };

console.log(objB); // { name: 'Pepe', age: 23 }
```

El spread operator se convierte as铆 en un mecanismo para la **copia o clonaci贸n** de objetos (incluidos arrays): obtener una nueva instancia con las mismas propiedades o incluso con la mutaci贸n de algunas

Este mecanismo no afecta a niveles anidados, es decir a arrays de arrays o propiedades de tipo objeto, por lo que se denomina **shallow copy**

![Shallow copy](assets/shallow.copy.svg)

#### Deep clone (or copy)

Para conseguir un deep clone pueden usarse 2 t茅cnicas

- uso de los m茅todos est谩ticos de JSON (stringify y parse)
- uso del la nueva funci贸n global `structuredClone` incluida en las APIs del browser y node (desde su versi贸n 11)

```js
const user = {
  name: {
    firstName: 'Pepe',
    surname: 'Perez',
  },
  age: 22,
};

const userB = JSON.parse(JSON.stringify(user));
console.log(userB);

const userC = structuredClone(userB);
console.log(userC);
```

### Operador rest

El operador rest al usarse en la sintaxis de los par谩metros de una funci贸n le permite recibir un n煤mero indefinido de argumentos como un array, permitiendo as铆 representar funciones 'variadicas' (variadic functions) en JavaScript

```js
const sumNumbers = (...numbers) => {
  let accumulator = 0;
  for (const iterator of numbers) {
    accumulator += iterator;
  }
  return accumulator;
};

console.log(sumNumbers(2, 5, 3, 5, 2, 7, 7)); // 31
```

Tambi茅n puede emplearse el operador rest como parte del proceso de des-estructuraci贸n

```js
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...others] = numbers;
console.log(others); // [ 3, 4, 5 ]
```

Est茅 煤ltimo caso puede igualmente ocurrir con objetos [_锔ES2018_]

```js
const { first, second, ...others } = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5,
};

console.log(first); // 1
console.log(second); // 2
console.log(others); // { third: 3, fourth: 4, fifth: 5 }
```

## Objetos

Como ya sabemos acerca de los objetos

- son valores de tipo referenciado
- son colecciones de **propiedades**, que a su vez son pares clave-valor
- los valores de las propiedades corresponden a datos de cualquier tipo: primitivos, objetos o funciones
  - En el caso de los arrays, los identificadores de las propiedades son indices num茅ricos que permiten la iteraci贸n a lo largo del array
- cuando una propiedad es de tipo funci贸n se denomina m茅todo.

### Creaci贸n y tipos de objetos

Los objetos pueden declararse:

- literalmente
- con el patron constructor

#### Objetos literales

JS permite crear de forma literal objetos, arrays y expresiones regulares (RegExp),
todos ellos variaciones del tipo **object**

```js
const user = {
  name: 'Pepe',
  age: 22,
};

// Array
const numbers = [1, 2, 3, 4];

// Regular Expression (RegExp)
const regExp = /a/i;

console.log(user); // { name: 'Pepe', age: 22 }
console.log(numbers); // [ 1, 2, 3, 4 ]
console.log(regExp); // /a/i
```

Esta forma de notaci贸n se conoce con **JavaScrip Object Notation (JSON)** y ha dado lugar a un formato de **ficheros, json**, convertido pr谩cticamente en el est谩ndar de intercambio de datos entre distintas capas de software (servidores, clientes...)

- se utilizan siempre dobles comillas (")
- las claves o propiedades siempre van entre comillas, al igual que los valores de tipo string

El formato literal es solo una notaci贸n.
Los objetos obtenidos son exactamente los mismos que los que resultar铆an del patron constructor: instancias de la misma funci贸n constructora y con el mismo prototipo, del que pueden tomar las propiedades comunes a todas las instancias de dicha funci贸n constructora (clase)

```js
const user = {
  name: 'Pepe',
  age: 22,
};

// Array
const numbers = [1, 2, 3, 4];

// Regular Expression (RegExp)
const regExp = /a/i;

console.log(user);
console.log(user.constructor); // [Function: Object]
console.log(Object.getPrototypeOf(user)); // [Object: null prototype] {}
console.log(user instanceof Object); // true

console.log(numbers);
console.log(numbers.constructor); // [Function: Array]
console.log(Object.getPrototypeOf(numbers)); // Object(0) []
console.log(numbers instanceof Object); // true
console.log(numbers instanceof Array); // true

console.log(regExp);
console.log(regExp.constructor); // [Function: RegExp]
console.log(Object.getPrototypeOf(regExp)); // {}
console.log(regExp instanceof Object); // true
console.log(regExp instanceof RegExp); // true
```

#### Objetos construidos

Desde la aparici贸n de JS, Los objetos pueden crearse como nuevas **instancias** resultantes de emplear el patron constructor (new) con una **funci贸n constructora**, de forma similar a como otros lenguajes utilizan las clases.

A partir de ES6, comienza a usarse la palabra reservada **class** y se habla de **clases** para referirse al proceso antes mencionado, de creaci贸n de instancias a partir de funciones constructoras (ahora con apariencia de clases)

```js
const user = new Object({
  name: 'Pepe',
  age: 22,
});

console.log(user); // { name: 'Pepe', age: 22 }

// Array
const numbers = new Array(1, 2, 3, 4);
console.log(numbers); // [ 1, 2, 3, 4 ]

// Regular Expression (RegExp)
const regExp = new RegExp(/a/i);
console.log('RegExp new', regExp); // /a/i

// Date
const date = new Date();
console.log(date); // 2023-08-19T11:56:56.079Z

// Error
const error = new Error('Some error');
console.log(error); // Error: Some error
```

### Propiedades de los objetos

Cualquiera que sea la forma en que se han creado, los objetos tienen propiedades a las que se puede acceder mediante dos formas de notaci贸n

- puntos (dot notation)
- corchetes (bracket notation)

```js
{
  const user = {
    name: 'Pepe',
  };
  console.log(user['name']); // Pepe

  const property = 'name';
  console.log(user[property]); // Pepe
}
```

La notaci贸n de corchetes solo se utiliza si el **nombre de la propiedad** es una **variable**, que debe ser evaluada para luego acceder a la propiedad correspondiente al valor de la variable

Con ambas notaciones es posible leer, modificar crear y eliminar propiedades.

```js
const obj = {
  name: 'Pepe',
  age: 22,
};
// A帽adimos propiedades
obj.lastName = 'Perez';
// Modificamos propiedades
obj.name = 'Jose';
// Eliminamos propiedades
delete obj.age;
console.log(obj);
```

Todos estos cambios se enmarcan en el concepto de **mutabilidad** de los objetos

#### Niveles

Las propiedades de los objetos pueden ser otros objetos, dando lugar a tantos niveles de anidamiento o profundidad como sea necesario.

As铆 se refleja tanto en su creaci贸n como en el acceso a las propiedades en cualquiera de las notaciones.

```js
const user = {
  name: {
    firstName: 'Pepe',
    surname: 'Perez',
  },
};
user.address = {};
user.address.street = 'c/ del Pez';
user['address'].number = '22 3陋 C';
user['address']['city'] = 'Teruel';

console.log(user);
// { name: { firstName: 'Pepe', surname: 'Perez' },
// address: { street: 'c/ del Pez', number: '22 3陋 C', city: 'Teruel' } }
```

##### Anidamiento y propiedades undefined

Si se accede a cualquier propiedad de un objeto que no existe, el valor devuelto es undefined

Sin embargo si se intenta acceder a una propiedad de una propiedad que no existe, de desencadena un TypeError.

Para evitarlo puede usarse el operador **optional chaining** (?.), que no continua a un siguiente nivel de anidamiento cuando obtiene un undefined o null en el anterior, devolviendo en ese caso un undefined

```js
const obj = {
  name: 'Pepe',
  age: 22,
};
console.log(obj.address); // undefined
try {
  console.log(obj.address.city);
} catch (error) {
  console.log(error.name); // TypeError
  console.log(error.message); // Cannot read properties of undefined (reading 'city')
}
console.log(obj.address?.city); // undefined
```

##### Anidamiento y clonaci贸n

Este posible anidamiento debe tenerse en cuenta al plantear el proceso de clonaci贸n o deep copy de un objeto, consistente en crear una instancia nueva.

Algunas de las formas de obtener este resultado no lo hacen en profundidad, y solo crean una shallow copy de las estructuras anidadas:

- Object.assign()
- {...Object}

Existen otras alternativas que si crean una deep copy a todos los niveles:

- JSON.parse(JSON.stringify(object))
- structuredClone()

#### Iteraciones

Los objetos no son iterables, como arrays y strings, por lo que no pueden recorrerse en base a un 铆ndice num茅rico, como hacen for y for-of.

Las iteraciones en los objetos de JS pueden realizarse con la estructura for-in, que ya conocemos.

### Objetos y prototipos

Todos los objetos tiene una propiedad especial llamada `__proto__`" que apunta a otro objeto, conocido como su **prototipo**.
Los objetos acceden de forma transparente al objeto al que apunta la propiedad `__proto__`.

El prototipo de un objeto suele ser el **prototype** de la funci贸n constructora del objeto. De esta forma se aplica el **patr贸n prototype** para conseguir una relaci贸n entre objetos asimilable a las **clases** de otros lenguajes de programaci贸n

#### Propiedades del prototipo original

El prototipo por defecto de los objetos incluye una serie de propiedades y m茅todos accesibles de forma transparente por todos los objetos, que en general no se utilizan demasiado

```js
const obj = new Object({
  name: 'Pepe',
  age: 22,
});

console.log(obj.constructor);
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.isPrototypeOf({})); // false
console.log(obj.propertyIsEnumerable('name')); // true
console.log(obj.toString()); // [object Object]
console.log(obj.toLocaleString()); // [object Object]
console.log(obj.valueOf()); // { name: 'Pepe', age: 22 }
```

![Objeto y su prototipo por defecto](assets/object.proto.svg)

#### Prototipos y funciones

En t茅rminos protot铆picos, las funciones son objetos un poco especiales, que tienen una propiedad especial llamada `prototype` que apunta a otro objeto, conocido como su **prototipo**.

Este objeto, como cualquier otro, tiene una propiedad `__proto__` que por defecto apunta al prototipo de todos los objetos.

![Prototipo de una funci贸n](assets/object.function.proto.svg)

Por su parte, el objeto prototipo por defecto de todos los dem谩s es el prototipo de la funci贸n constructora Object.

Este objeto, como cualquier otro, tiene una propiedad `__proto__` que por defecto apunta a null.

![Prototipo de una funci贸n](assets/final.proto.svg)

#### Cambiando el prototipos

Se puede crear un objeto literal que tenga como prototipo (`__proto__`) cualquier otro objeto

La forma "incorrecta" de hacerlo es mediante la asignaci贸n directa de la propiedad `__proto__` al objeto literal

```js
const person = {
  teeth: 32,
  renderTeeth() {
    console.log('Tengo', this.teeth, 'dientes');
  },
};

const user = {
  name: 'Pepe',
  age: 22,
  __proto__:
}
user.__proto__= person;
```

La forma correcta de hacerlo es mediante la funci贸n `Object.create()`, que recibe como argumento el objeto que se desea que sea el prototipo del nuevo objeto

```js
const person = {
  teeth: 32,
};

const user = Object.create(person);

user.name = 'Pepe';
user.age = 22;

console.log(user);
user.renderTeeth(); // Tengo 32 dientes
```

Otra forma tambi茅n v谩lida es usando Object.setPrototypeOf(), que recibe como primer argumentos el objeto al que se le va a cambiar el prototipo y como segundo el objeto que va a ser el nuevo prototipo

```js
const person = {
  teeth: 32,
};

const user = {
  name: 'Pepe',
  age: 22,
};

Object.setPrototypeOf(user, person);

console.log(user);
user.renderTeeth(); // Tengo 32 dientes
```

En cualquiera de los casos, el nuevo objeto podr谩 acceder de forma transparenta a las propiedades de su prototipo, siempre que no existan en el mismo objeto

![Objetos como proto de otro objeto](assets/change.proto.svg)

#### Cadena de prototipos

La relaci贸n entre objetos y prototipos puede ser en cadena, de forma que un objeto puede ser el prototipo de otro objeto que a su vez es el prototipo de otro objeto. Este patr贸n se conoce como **cadena de prototipos** (**prototype chain**) y de lugar a la **herencia protot铆pica**

Si una propiedad no se encuentra en el objeto, se busca en su prototipo, y as铆 sucesivamente hasta llegar al prototipo de todos los objetos, Object.

```js
const alumno = {
  course: 'JavaScript',
  __proto__: person,
};

console.log(alumno);
console.log(alumno.name); // Pepe
alumno.renderTeeth(); // Tengo 32 dientes
```

![Cadena de prototipos (prototype chain)](assets/prototipe.chain.svg)

En cualquier punto de la cadena de prototipos puede darse es **ocultamiento** (**shadowing**) de propiedades disponibles en niveles superiores.
Si una propiedad se encuentra en el objeto, no se busca en su prototipo, ni en los sucesivos prototipos de la cadena.

## Paradigma funcional: funciones como objetos

Ya sabemos que en JS las funciones son tambi茅n valores y su tipo es el de **objetos 'de pleno derecho**.

Entre otras cosas

- pueden tener propiedades
- pueden ser asignadas a una variable
- pueden ser incluidas (anidadas) en otra funci贸n
- pueden ser recibidas como par谩metros
- pueden ser devueltas por otra funci贸n

### Funciones con propiedades 'extra'

Aunque no suele hacerse, una funci贸n puede tener propiedades como cualquier otro objeto

```js
const foo = () => {
  console.log('Soy foo');
};

foo.date = new Date();

console.log(foo);
// [Function: foo] { date: 2023-08-16T11:23:04.205Z }
```

### Funciones anidadas

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }

  return square(a) + square(b);
}

console.log(addSquares(4, 5)); // 41
```

La funci贸n 'interna' square solo existe en el scope de la otra y solo puede ser utilizada dentro de ella

### Funciones de orden superior y callbacks

Una funci贸n de orden superior (**hight order function**) es la que

- recibe una funci贸n como par谩metro
- devuelve una funci贸n

La funci贸n recibida como par谩metro se denomina **callback**

```js
const hof = (callback) => {
  console.log(callback());
};

hof(() => 'Soy un callback');
```

Los callback pueden ser indistintamente funciones con nombre o an贸nimas, aunque esta segunda opci贸n es muy habitual, como lo es en ese caso el uso de las arrow functions

Entre los usos m谩s habituales de los callbacks:

- permitir asignar funciones como manejadores de eventos as铆ncronos
- asignar funciones a timeouts, como otra forma de asincron铆a

### Funciones auto-invocadas

Despu茅s de la declaraci贸n de una funci贸n an贸nima (expresi贸n funcional), es posible que 茅sta se invoque a si misma para ser ejecutada inmediatamente

El patr贸n de esta pr谩ctica se denomina IIFE (**Immediately Invoked Function Expression**)

```js
(() => {
  console.log('Ejemplo de una IIFE');
})();
```

La creaci贸n de su propio espacio de memoria en las funciones hace que se puedan utilizar para aislar un c贸digo fuente y evitar colisiones de variables o espacios de nombres en general: El c贸digo se ejecuta directamente, como si no hubiera funci贸n, pero en su propio espacio de memoria

### Closures

Una funci贸n que encapsula un conjunto de definiciones locales :

- variables,
- otras funciones (por extensi贸n objetos).

Se basa por tanto en el anidamiento de funciones.

- permite que la funci贸n interna "escape" de la funci贸n padre: se hace accesible desde fuera
- la funci贸n interna sigue teniendo acceso al 谩mbito (scope) de la funci贸n padre despu茅s de que 茅sta haya retornado

El 谩mbito de visibilidad de la funci贸n externa se utiliza para crear el equivalente a un m贸dulo

Las funciones internas pueden ser setters y getters de variables locales, no accesibles directamente desde fuera

Se pueden utilizar varios patrones para conseguir un closure:

- una funci贸n incluye una funci贸n interna y la devuelve
- una funci贸n incluye una funci贸n interna y se la asigna a una variable del nivel superior

```js
const closureCount = () => {
  let counter = 0;
  return () => counter++;
};

const extCounter = closureCount();

console.log(extCounter()); // 0
console.log(extCounter()); // 1
console.log(extCounter()); // 2
```

En el primero de los patrones puede a帽adirse una IIFE

```js
const closureCount = (() => {
  let counter = 0;
  return () => counter++;
})();

console.log(closureCount()); // 0
console.log(closureCount()); // 1
console.log(closureCount()); // 2
```

## Paradigma de orientaci贸n a objetos: clases

Como hemos visto, en JS Los objetos pueden declararse:

- literalmente
- con el patron constructor

Los objetos literales tienen como caracter铆stica que en principio creamos cada uno de forma independiente, lo que en muchos contextos no es lo m谩s adecuado.

```js
const user1 = {
  name: 'Pepe',
  age: 22,
  greeting() {
    console.log(`Hola, soy ${this.name}`);
  },
};

const user2 = {
  name: 'Ernestina',
  age: 23,
  greeting() {
    console.log(`Hola, soy ${this.name}`);
  },
};

user1.greeting();
user2.greeting();

console.log(user1);
console.log(user2);
```

La alternativa es el patr贸n constructor, y para entenderlo es necesario conocer los distintos patrones de ejecuci贸n de las funciones en JS.

### Patrones de ejecuci贸n de las funciones

Una funci贸n puede ser ejecutada de 4 formas diferentes, y en cada una de ellas el valor de `this` es diferente

Tomamos como ejemplo una funci贸n que simplemente imprime el valor de `this`

```js
function foo() {
  console.log('Este es el valor de this:', this);
}
```

Podemos ejecutarla siguiendo 4 patrones diferentes

- como una funci贸n (**function pattern**)

El valor de this depende de si esta activado o no el modo estricto

- si no lo est谩, this es el objeto global
- si lo est谩, this es undefined

```js
foo(); // Este es el valor de this: <ref *1> Object [global] { ... }

('use strict');
foo(); // Este es el valor de this: undefined
```

- como un m茅todo (**method pattern**)

El valor de this es el objeto al que pertenece la funci贸n
Para probarlo asignamos la funci贸n a una propiedad de un objeto y la invocamos

```js
const obj = {
  foo, // Eq. foo: foo
};

obj.foo(); // Este es el valor de this: { foo: [Function: foo] }
```

- como un constructor (**constructor pattern**)

La funci贸n se invoca con el operador new, y el valor de this es un objeto vac铆o que se crea autom谩ticamente y se asigna a la variable this

```js
new foo(); // Este es el valor de this: foo {}
```

- de forma indirecta (**apply/call pattern**)

La funci贸n puede ser invocada desde el contexto de otro objeto, mediante los m茅todos apply o call de la propia funci贸n, que permiten asignar un valor a this pasado como argumento.

```js
const obj2 = {
  name: 'Object 2',
};

foo.apply(obj2); // Este es el valor de this: { name: 'Object 2' }
```

En definitiva vemos que cualquier funci贸n puede ser un constructor, cuando se una el operador new. En ese caso

1 - Se crea un objeto nuevo
2 - Este es asignado a la propiedad this de la funci贸n
3 - El c贸digo de la funci贸n puede modificar el objeto reci茅n creado
3 - La funci贸n devuelve el objeto

### Funciones constructoras

Lo interesante es implementar funciones pensadas para ser usadas como constructores, y que devuelvan un objeto con propiedades y m茅todos. Estas funciones se denominan **funciones constructoras** y pos convenio se escriben con la primera letra en may煤sculas

```js
function User(name, age) {
  this.name = name;
  this.age = age;
  this.greeting = function () {
    console.log(`Hola, soy ${this.name}`);
  };
}

const user1 = new User('Pepe', 33);
const user2 = new User('Ernestina', 22);
const user3 = new User('Ramon', 45);

console.log(user1);
console.log(user2);
console.log(user3);
```

El patr贸n constructor es el m谩s habitual en la **programaci贸n orientada a objetos** en JS, y se utiliza para crear instancias de objetos que comparten propiedades y m茅todos.

De forma similar a como hacen las clases en otros lenguajes, las funciones constructoras permiten crear instancias de objetos con propiedades y m茅todos comunes.
Hay sin embargo una importante diferencia entre ambos conceptos:

- Los objetos basados en clases de otros lenguajes se ajusta r铆gidamente a las definiciones de la clase, que pueden entenderse como **plantillas** con las que se crean objetos
- Los objetos basados en funciones constructoras de JS son tan flexibles como los objetos literales, y permiten la creaci贸n de objetos con propiedades y m茅todos comunes, pero tambi茅n la modificaci贸n de esas propiedades y m茅todos en cada instancia

```js
const user4 = new User('Pepe', 33);
user4.surname = 'Perez';
delete user4.age;

console.log(user4); // { name: 'Pepe', greeting: [Function], surname: 'Perez' }
```

#### Funciones constructoras y prototipos

Cuando una funci贸n utiliza el patr贸n constructor, se crea un objeto que tiene como prototipo el prototipo de la funci贸n constructora.

```js
const User = function (name, age) {
  this.name = name;
  this.age = age;
};

Person.prototype.teeth = 32;

const pepe = new Person('Pepe', 22);
console.log(pepe);
console.log(pepe.teeth); // 32
```

El objeto creado con el operador new tiene adem谩s una propiedad especial `constructor` que apunta a la funci贸n constructora.

```js
pepe.__proto__ === Person.prototype; // true
pepe.constructor === Person; // true
```

![Prototipos y funciones constructoras](assets/constructor.prototype.svg)

#### M茅todos de instancia y m茅todos de prototipo

En el ejemplo anterior, el m茅todo `greeting` es un m茅todo de instancia, ya que se crea en cada objeto creado con la funci贸n constructora. Esto puede ser un problema si se crean muchos objetos, ya que se duplica el c贸digo de la funci贸n en cada uno de ellos.

En JS lo habitual es almacenar los m茅todos en el prototipo de la funci贸n constructora, de forma que se comparten entre todas las instancias de la funci贸n constructora, siendo accesibles de forma transparente, como ya sabemos que sucede con todas las propiedades del prototipo. As铆 se muestra en la imagen anterior

```js
const User = function (name, age) {
  this.name = name;
  this.age = age;
};

User.prototype.greeting = function () {
  console.log(`Hola, soy ${this.name}`);
};

const pepe = new User('Pepe', 22);
const ernestina = new User('Ernestina', 23);

pepe.greeting();
ernestina.greeting();

console.log(pepe);
console.log(ernestina);
```

#### Propiedades y M茅todos est谩ticos (de "clase")

La propia funci贸n constructora puede tener propiedades y m茅todos que no se comparten con las instancias de la funci贸n constructora, sino que son propias de la funci贸n constructora.

Estas propiedades y m茅todos se denominan **est谩ticos** y se definen directamente en la funci贸n constructora

```js
const User = function (name, age) {
  this.name = name;
  this.age = age;
  User.count++;
};

User.prototype.greeting = function () {
  console.log(`Hola, soy ${this.name}`);
};

User.count = 0;
User.getCount = function () {
  return User.count;
};

const pepe = new User('Pepe', 22);
const ernestina = new User('Ernestina', 23);

console.log(User.getCount()); // 2
```

#### Herencia

En JS la herencia se basa en la cadena de prototipos, y se consigue mediante la asignaci贸n de un objeto a la propiedad `prototype` de la funci贸n constructora

```js
const Person = function (name, age) {
  this.name = name;
  this.age = age;
};

Person.prototype.greeting = function () {
  console.log(`Hola, soy ${this.name}`);
};

const Student = function (name, age, course) {
  Person.call(this, name, age);
  this.course = course;
};

Student.prototype = Object.create(Person.prototype);
// Student.prototype.__proto__ = Person.prototype;
Student.prototype.constructor = Student;

Student.prototype.greeting = function () {
  Person.prototype.greeting.call(this);
  console.log(`Estudio ${this.course}`);
};

const pepe = new Student('Pepe', 22, 'JavaScript');
pepe.greeting();
```

En este caso, la funci贸n constructora Student hereda de la funci贸n constructora Person, y se crea una nueva cadena de prototipos, en la que el prototipo de Student es el prototipo de Person.

![Herencia en JS](assets/proto.inheritance.svg)

#### Funciones constructoras nativas de JS

JS incluye funciones constructoras nativas que permiten crear objetos de tipos primitivos y objetos

- String
- Number
- Boolean
- Array
- Object
- Function
- ...

En los prototipos de estas funciones constructoras se encuentran los m茅todos y propiedades que permiten trabajar con estos tipos de datos, al ser accedidas de forma transparente por todos los objetos creados con estas funciones constructoras.

```js
const str = 'Hola';
console.log(str.length); // 4
console.log(str.toUpperCase()); // HOLA
const arr = [1, 2, 3];
console.log(arr.length); // 3
console.log(arr.push(4)); // 4
console.log(Array.isArray(arr)); // true
```

En muchos casos, estas funciones constructoras se utilizan tanbien como funciones de conversi贸n de tipos, para convertir valores de un tipo a otro, cuando de invocan con el patr贸n function, es decir sin el operador new

```js
const num = Number('22');
console.log(typeof num); // number
```

Todas ellas heredan de la funci贸n constructora Object, y por tanto tienen acceso a las propiedades y m茅todos de Object, que por su parte tiene como prototipo el valor null, que de esa forma pone fin a la cadena de prototipos.

```js
const data = [1, 2, 3];
console.log(data.constructor); // [Function: Array]
console.log(data instanceof Array); // true
console.log(data instanceof Object); // true

const foo = () => {};
console.log(foo.constructor); // [Function: Function]
console.log(foo instanceof Function); // true
console.log(foo instanceof Object); // true

const obj = {};
console.log(obj.constructor); // [Function: Function]
console.log(obj instanceof Object); // true
```

![Funciones constructoras nativas y creadas por el usuario](assets/native.constructors.svg)

### Clases en ES6

A partir de ES6, JS incluye la palabra reservada **class** que permite definir una funci贸n constructora de forma m谩s clara y sencilla, y que se asemeja a la sintaxis de las clases de otros lenguajes de programaci贸n.

Internamente no cambia nada respecto a lo que hemos visto hasta ahora, y sigue siendo una funci贸n constructora que crea objetos con propiedades y m茅todos. Por eso se dice que las clases en JS son **az煤car sint谩ctica**. Prueba de ello es que los objetos siguen siendo igual de flexibles que antes

```js
export class User {
  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }

  greeting() {
    console.log(`Hola, soy ${this.name} y tengo ${this.#age} a帽os`);
  }
}

const user1 = new User('Pepe', 33);
const user2 = new User('Ernestina', 22);
const user3 = new User('Ramon');

user1.greeting();
user2.greeting();

// Los objetos siguen siendo igual de flexibles que antes
user1.surname = 'Perez';
delete user1.age;

console.log(user1);
console.log(user2);
console.log(user3);
```

Su uso hoy en d铆a esta muy extendido y es el m谩s habitual en la programaci贸n orientada a objetos en JS. Algunas novedades posteriores a ES6 han mejorado su funcionalidad, como la posibilidad de declarar propiedades est谩ticas y m茅todos est谩ticos, y la posibilidad de declarar propiedades privadas. Con ello la OOP en JS al menos en t茅rminos formales, se ha acercado m谩s a la de otros lenguajes de programaci贸n.

```js
export class User {
  static brand = 'CAS';

  static foo = function () {
    console.log('M茅todo est谩tico');
  };

  name;
  #age;

  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }

  greeting() {
    console.log(`Hola, soy ${this.name} y tengo ${this.#age} a帽os`);
  }
}

const user1 = new User('Pepe', 33);

user1.greeting();

console.log(User.brand);
User.foo();

console.log(user1);
```

En el caso de la herencia, las ventajas del nuevo formato son aun m谩s evidentes, ya que la sintaxis es mucho m谩s clara y sencilla

```js
export class Student extends User {
  constructor(name, age, course = 'Angular') {
    super(name, age);
    this.course = course;
  }

  greeting() {
    super.greeting();
    console.log(`Estudio ${this.course}`);
  }
}

const s1 = new Student('Elena', 34, 'Node');
s1.greeting();
console.log(s1);
```

### Accessors: getters y setters

A partir de ES5, JS incluye la posibilidad de declarar propiedades de un objeto como getters y setters, que permiten controlar la lectura y escritura de las propiedades de un objeto.

Estos m茅todos han cobrado mayor sentido al aparecer la posibilidad de declarar propiedades privadas en las clases de ES6.

Sin embargo, el uso de getters y setters aparece como una mala practica en la mayor铆a de las referencias a la OOP como paradigma de programaci贸n.

```js
export class User {
  #name;
  #age;

  constructor(name, age) {
    this.#name = name;
    this.#age = age;
  }

  get name() {
    return this.#name;
  }

  set name(value) {
    this.#name = value;
  }

  get age() {
    return this.#age;
  }

  set age(value) {
    this.#age = value;
  }

  greeting() {
    console.log(`Hola, soy ${this.#name} y tengo ${this.#age} a帽os`);
  }
}

const user1 = new User('Pepe', 33);
user1.greeting();

console.log(user1.name);
user1.name = 'Ernestina';
console.log(user1.name);
```

### JS y la programaci贸n orientada a objetos

Como acabamos de ver las novedades de ES6 y versiones posteriores han acercado la programaci贸n orientada a objetos en JS a la de otros lenguajes de programaci贸n, pero no han cambiado la naturaleza de JS como lenguaje de programaci贸n.

JS sigue siendo un lenguaje de programaci贸n orientado a objetos, pero no basado en clases, sino en prototipos, y con una sintaxis que permite la creaci贸n de objetos de forma literal, con funciones constructoras, o aparentemente con clases.

Los objetos en JS son tan flexibles como los objetos literales, y permiten la creaci贸n de objetos con propiedades y m茅todos comunes, pero tambi茅n la modificaci贸n de esas propiedades y m茅todos en cada instancia. Todo ello no es muy coherente con el concepto de **encapsulaci贸n**

Adem谩s una diferencia de JS respecto a otros lenguajes de programaci贸n es la falta de **clases abstractas** e **interfaces**. Ello dificulta la abstracci贸n y el polimorfismo basado en interfaces, la creaci贸n de jerarqu铆as de clases y la aplicaci贸n de determinados patrones habituales en OOP.

Una de las formas de abordar estas limitaciones es el uso de **TypeScript**, un **super-conjunto de JS** que a帽ade tipado est谩tico y caracter铆sticas de OOP como objetos mucho menos manipulables, clases abstractas e interfaces, y que se compila a JS.
